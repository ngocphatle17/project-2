bank_simulation: python code to implement the project.
run1.txt: test results of the python code. 

When implementing the project, the thread synchronization and managing shared resources really challenged me. First, I thought several tellers would serve the same customer, or a teller would serve the customer who was not in the queue anymore, because I did not implement the access limit to share data structures like the customer_quque and teller_available. I fixed it by creating queue_lock to wrap all sections that modified the shared state and make it easier to maintain data integrity. Then, I ran into a problem when dealing with the semaphores to control access to limit the access, so I ran into the hang for my program, teller would wait forever to access and never release the lock. I fixed it by using statements to ensure the semaphores were always releasing, or in the worst case, the teller was interrupted. Then, it was hard for me to end the simulation. Some tellers waited for customers forever after all the customers had already been served. I fixed it by implementing all teller semaphores one more time after all customers were served. By that, the teller could check the queue and end if the queue is empty.